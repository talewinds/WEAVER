<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wish Weaver — Digital Card Creator</title>
  <meta name="description" content="Wish Weaver — Create beautiful shareable cards in your browser. Local processing. Add stickers, custom text, rotate, scale, and export high-resolution PNGs." />
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Oswald:wght@400;700&family=Caveat:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    .font-inter { font-family: 'Inter', sans-serif; }
    .font-oswald { font-family: 'Oswald', sans-serif; }
    .font-caveat { font-family: 'Caveat', cursive; }
    .font-mono { font-family: 'Roboto Mono', monospace; }

    .draggable-text {
      position: absolute;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
      padding: 6px 10px;
      border: 2px dashed rgba(255,255,255,0.5);
      transform: translate(-50%, -50%);
      transition: opacity 0.15s, transform 0.1s;
      max-width: 90%;
      overflow-wrap: break-word;
      z-index: 5;
      touch-action: none;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.45);
    }
    .draggable-text:active { cursor: grabbing; }
    .sticker-layer {
      position: absolute;
      touch-action: none;
      transform-origin: center center;
      z-index: 3;
      user-select: none;
      -webkit-user-select: none;
      cursor: grab;
    }
    .sticker-layer img { display:block; max-width:100%; height:auto; pointer-events: none; }

    #previewContainer { touch-action: none; }

    .draggable-text:focus, .sticker-layer:focus { outline: 2px dashed rgba(30,64,175,0.85); outline-offset: 6px; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
    ::-webkit-scrollbar-track { background: #f0f4f8; }

    /* sticker thumbnail style */
    .sticker-thumb img { display:block; width:100%; height:100%; object-fit:contain; }

    /* Ad placeholders */
    .adsense-placeholder {
      min-height: 90px;
      border: 2px dashed #34d399;
      background-color: #e0fcf4;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#065f46;
      font-weight:600;
      border-radius:10px;
      text-align:center;
    }
    .adsense-small { min-height:60px; }
    .adsense-rect { min-height:120px; }

    /* nicer upload placeholder background & watermark link style */
    #imagePlaceholder {
      background: linear-gradient(135deg, #fbf8ff 0%, #f6fbff 50%, #fff8f5 100%);
      color: #374151;
      gap: 8px;
    }
    /* clickable watermark overlay inside preview */
    #previewWatermark {
      position: absolute;
      left: 50%;
      bottom: 6px;
      transform: translateX(-50%);
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.5);
      color: #0b3b73;
      text-decoration: underline;
      cursor: pointer;
      z-index: 60;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    #previewWatermark:hover { background: rgba(255,255,255,0.75); }
  </style>
</head>
<body class="bg-gray-50 font-inter text-gray-800 min-h-screen flex flex-col">

  <!-- Header -->
  <header class="bg-blue-900 text-white">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
      <h1 class="text-2xl font-bold"><span class="text-yellow-300">W</span>ish <span class="text-yellow-300">W</span>eaver</h1>
      <div class="flex items-center gap-3">
        <button id="helpButton" class="bg-yellow-300 text-blue-900 px-3 py-2 rounded-full font-semibold">How to Use</button>
        <button id="saveDesign" class="bg-emerald-500 text-white px-3 py-2 rounded-md">Save</button>
        <button id="loadDesign" class="bg-gray-200 text-gray-800 px-3 py-2 rounded-md">Load</button>
        <button id="clearSaved" class="bg-red-100 text-red-700 px-3 py-2 rounded-md">Clear Saved</button>
      </div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-6xl mx-auto w-full flex-grow grid lg:grid-cols-3 gap-8 p-6">

    <!-- Left Column: Controls -->
    <section class="lg:col-span-1 space-y-6">

      <!-- Ad slot (top) -->
      <div class="adsense-placeholder adsense-small">
        Ad placeholder — Leaderboard / AdSense (300x100). Replace with AdSense code.
      </div>

      <div class="p-6 bg-white rounded-xl shadow">
        <h2 class="font-bold text-lg text-blue-800 mb-3">1. Choose Canvas</h2>
        <input id="imageUpload" type="file" accept="image/*" aria-label="Upload image" class="w-full text-sm" />
        <p id="fileWarn" class="text-sm text-red-600 mt-2 hidden"></p>
        <div class="mt-4">
          <label class="block text-sm mb-1">Aspect Ratio</label>
          <select id="aspectRatio" class="w-full p-2 rounded border">
            <option value="1:1">Square — 1:1</option>
            <option value="4:5">Portrait — 4:5 (Instagram)</option>
            <option value="9:16">Story — 9:16</option>
          </select>
        </div>
        <div class="mt-4">
          <label class="block text-sm mb-1">Export DPI</label>
          <select id="exportDpr" class="w-full p-2 rounded border">
            <option value="1">1x (normal)</option>
            <option value="2" selected>2x (retina)</option>
            <option value="3">3x (very high)</option>
          </select>
        </div>
      </div>

      <!-- Text Customization -->
      <div class="p-6 bg-white rounded-xl shadow space-y-4">
        <h2 class="font-bold text-lg text-blue-800">2. Customize Text</h2>

        <div>
          <label class="text-sm block mb-1">Main Wish</label>
          <input id="wishText" class="w-full p-2 border rounded" maxlength="100" value="Happy Moments!" />
          <div class="flex items-center gap-2 mt-2">
            <input id="wishColor" type="color" value="#ffffff" title="Wish color" />
            <input id="wishSize" type="number" min="14" max="200" value="48" class="w-20 p-1 border rounded text-center" title="Font size" />
            <select id="wishFont" class="flex-1 p-1 border rounded">
              <option value="font-oswald">Oswald (Bold)</option>
              <option value="font-caveat">Caveat (Cursive)</option>
              <option value="font-inter" selected>Inter (Modern)</option>
              <option value="font-mono">Roboto Mono</option>
            </select>
          </div>
          <div class="mt-2 flex items-center gap-2 text-sm">
            <label class="flex items-center gap-1"><input id="wishStrokeEnable" type="checkbox" /> Stroke</label>
            <input id="wishStrokeColor" type="color" value="#000000" />
            <input id="wishStrokeWidth" type="number" min="0" max="20" value="2" class="w-20 p-1 border rounded text-center" />
            <label class="ml-auto text-xs text-gray-500">Rotate:</label>
            <input id="wishRotate" type="range" min="-180" max="180" value="0" class="w-32" />
          </div>
        </div>

        <div>
          <label class="text-sm block mb-1">Sub Text (max 20 words)</label>
          <textarea id="subText" class="w-full p-2 border rounded" rows="2">Wishing you a wonderful day filled with joy and laughter!</textarea>
          <div class="flex items-center gap-2 mt-2">
            <input id="subColor" type="color" value="#facc15" />
            <input id="subSize" type="number" min="10" max="120" value="20" class="w-20 p-1 border rounded text-center" />
            <select id="subFont" class="flex-1 p-1 border rounded">
              <option value="font-inter">Inter</option>
              <option value="font-oswald">Oswald</option>
              <option value="font-caveat">Caveat</option>
              <option value="font-mono">Roboto Mono</option>
            </select>
          </div>
          <div class="mt-2 flex items-center gap-2 text-sm">
            <label class="flex items-center gap-1"><input id="subStrokeEnable" type="checkbox" /> Stroke</label>
            <input id="subStrokeColor" type="color" value="#000000" />
            <input id="subStrokeWidth" type="number" min="0" max="20" value="1" class="w-20 p-1 border rounded text-center" />
            <label class="ml-auto text-xs text-gray-500">Rotate:</label>
            <input id="subRotate" type="range" min="-180" max="180" value="0" class="w-32" />
          </div>
        </div>
      </div>

      <!-- Sticker Picker -->
      <div class="p-6 bg-white rounded-xl shadow">
        <h2 class="font-bold text-lg text-blue-800 mb-3">3. Stickers</h2>
        <p class="text-sm text-gray-600 mb-2">Click a sticker to add it to the canvas.</p>
        <div id="stickerPalette" class="grid grid-cols-4 gap-2">
          <button class="sticker-thumb p-1 bg-white rounded border" data-src="https://twemoji.maxcdn.com/v/latest/72x72/1f389.png"><img src="https://twemoji.maxcdn.com/v/latest/72x72/1f389.png" alt="party" class="w-12 h-12" /></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-src="https://twemoji.maxcdn.com/v/latest/72x72/1f381.png"><img src="https://twemoji.maxcdn.com/v/latest/72x72/1f381.png" alt="gift" class="w-12 h-12" /></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-src="https://twemoji.maxcdn.com/v/latest/72x72/1f382.png"><img src="https://twemoji.maxcdn.com/v/latest/72x72/1f382.png" alt="cake" class="w-12 h-12" /></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-src="https://twemoji.maxcdn.com/v/latest/72x72/1f496.png"><img src="https://twemoji.maxcdn.com/v/latest/72x72/1f496.png" alt="sparkling heart" class="w-12 h-12" /></button>
        </div>

        <!-- Ad placeholder between sticker picker and sticker controls -->
        <div class="mt-3 adsense-placeholder adsense-rect">
          Ad placeholder — Rectangle (replace with AdSense code)
        </div>

        <!-- Sticker controls -->
        <div id="stickerControls" class="mt-4 hidden space-y-2">
          <p class="text-sm">Selected Sticker Controls</p>
          <div class="flex items-center gap-2">
            <label class="text-xs">Scale</label>
            <input id="stickerScale" type="range" min="0.2" max="3" step="0.05" value="1" class="flex-1" />
            <label class="text-xs">Rotate</label>
            <input id="stickerRotate" type="range" min="-180" max="180" value="0" class="w-32" />
          </div>
          <div class="flex gap-2">
            <button id="bringForward" class="px-3 py-1 bg-white rounded border">Bring Forward</button>
            <button id="sendBack" class="px-3 py-1 bg-white rounded border">Send Back</button>
            <button id="deleteSticker" class="px-3 py-1 bg-red-100 text-red-700 rounded border">Delete</button>
          </div>
        </div>
      </div>

      <!-- Quick Actions NOTE: action buttons moved below preview as requested -->
      <div class="p-6 bg-white rounded-xl shadow flex flex-col gap-3">
        <div class="text-sm text-gray-600"></div>
      </div>
    </section>

    <!-- Right Column: Preview & Output -->
    <section class="lg:col-span-2">
      <div class="bg-white rounded-xl shadow p-4">
        <h2 class="font-bold text-lg text-green-700 mb-3">Live Preview</h2>

        <div id="previewContainer" class="relative mx-auto overflow-hidden rounded-lg bg-gray-200 border-4 border-blue-800 max-w-2xl" style="aspect-ratio: 1 / 1; width:100%;">
          <canvas id="cardCanvas" class="w-full h-full"></canvas>

          <!-- Text overlays -->
          <div id="wishOverlay" class="draggable-text font-oswald text-white" tabindex="0"
               style="top:25%; left:50%; font-size:48px; transform: translate(-50%, -50%) rotate(0deg);">
            Happy Moments!
          </div>

          <div id="subOverlay" class="draggable-text font-inter text-yellow-300" tabindex="0"
               style="top:80%; left:50%; font-size:20px; transform: translate(-50%, -50%) rotate(0deg);">
            Wishing you a wonderful day filled with joy and laughter!
          </div>

          <!-- Sticker container (DOM overlays) -->
          <div id="stickerLayerContainer"></div>

          <div id="imagePlaceholder" class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 pointer-events-none">
            <svg class="w-16 h-16 mb-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 003-2V6a2 2 0 00-2-2H6"></path></svg>
            <p class="text-lg font-semibold">Upload an image to start</p>
          </div>

          <!-- Clickable watermark overlay (bottom-center, clickable) -->
          <a id="previewWatermark" href="https://weaver.example.com" target="_blank" rel="noopener">designed by weaver</a>
        </div>

        <!-- Buttons moved to below the uploaded picture, just above the ad -->
        <div class="mt-4 flex gap-3 items-center justify-center">
          <button id="resetButton" class="px-4 py-2 rounded bg-gray-200">Reset All</button>
          <button id="undoButton" class="px-4 py-2 rounded bg-yellow-400 disabled:opacity-50" disabled>Undo</button>
          <!-- Added onclick handler referencing handleGenerateClick to make button robust -->
          <button id="generateButton" onclick="handleGenerateClick(event)" class="px-4 py-2 rounded bg-green-600 text-white disabled:opacity-50" disabled>GENERATE SHARABLE CARD</button>
        </div>

        <!-- Ad slot below preview (responsive) -->
        <div class="mt-4 adsense-placeholder">
          Ad placeholder — Responsive (replace with AdSense code)
        </div>

        <!-- Output -->
        <div id="outputArea" class="mt-6 hidden bg-gray-50 p-4 rounded text-center">
          <p class="font-semibold text-blue-700">Your card is ready</p>
          <div class="mt-3 flex justify-center gap-3">
            <a id="downloadLink" class="inline-flex items-center gap-2 px-4 py-2 bg-blue-700 text-white rounded" download="wishweaver-card.png">Download PNG</a>
            <!-- New share buttons -->
            <button id="webShareBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded">Share (Web)</button>
            <button id="waShareBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded">WhatsApp</button>
            <button id="fbShareBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-blue-800 text-white rounded">Facebook</button>
          </div>
          <img id="finalImagePreview" class="mx-auto mt-4 rounded shadow max-w-sm" alt="Final card" style="display:none;" />
        </div>
      </div>
    </section>

  </main>

  <!-- Footer with SEO + Privacy + designed-by link -->
  <footer class="bg-white mt-8 py-8 px-6">
    <div class="max-w-6xl mx-auto grid md:grid-cols-3 gap-8 text-sm text-gray-600">
      <div>
        <h3 class="font-bold text-base text-blue-800 mb-2">About Wish Weaver</h3>
        <p>Wish Weaver is a local, browser-based card creator. Combine your photos with customizable messages, fonts, and stickers — then export high-resolution PNGs ready to share. No accounts, no uploads: your images stay on your device.</p>
      </div>

      <div>
        <h3 class="font-bold text-base text-blue-800 mb-2">Privacy Declaration</h3>
        <p><strong>We respect your privacy.</strong> All processing (image rendering, sticker placement, and export) happens entirely in your browser. Images and text are not uploaded to our servers unless you explicitly choose to share them. Saved designs are stored only in your browser's localStorage.</p>
      </div>

      <div>
        <h3 class="font-bold text-base text-blue-800 mb-2">Key Features</h3>
        <ul class="list-disc list-inside space-y-1">
          <li>Local browser processing — no uploads.</li>
          <li>Text layers with fonts, rotate, stroke, and keyboard nudging.</li>
          <li>Sticker/emoji picker with scalable, rotatable image layers.</li>
          <li>Multiple aspect ratios and high-resolution export.</li>
        </ul>
      </div>
    </div>

    <div class="max-w-6xl mx-auto mt-6 text-center text-xs text-gray-500">
      designed by <a id="weaverLink" href="https://weaver.example.com" target="_blank" rel="noopener" class="text-blue-700 underline">weaver</a> — &copy; 2025 Wish Weaver
    </div>
  </footer>

  <script>
  /************************************************************************
   * Wish Weaver — single-file app
   * Fixes applied:
   * 1) Robust generate button handler (handleGenerateClick) wired via onclick.
   * 2) Stroke thickness reduced and scaled for both live DOM preview and export.
   ************************************************************************/

  // DOM references
  const canvas = document.getElementById('cardCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const previewContainer = document.getElementById('previewContainer');
  const imageUpload = document.getElementById('imageUpload');
  const imagePlaceholder = document.getElementById('imagePlaceholder');
  const generateButton = document.getElementById('generateButton');
  const outputArea = document.getElementById('outputArea');
  const finalImagePreview = document.getElementById('finalImagePreview');
  const downloadLink = document.getElementById('downloadLink');
  const aspectRatio = document.getElementById('aspectRatio');
  const exportDpr = document.getElementById('exportDpr');
  const fileWarn = document.getElementById('fileWarn');

  const wishOverlay = document.getElementById('wishOverlay');
  const subOverlay = document.getElementById('subOverlay');
  const stickerPalette = document.getElementById('stickerPalette');
  const stickerLayerContainer = document.getElementById('stickerLayerContainer');
  const stickerControls = document.getElementById('stickerControls');
  const stickerScale = document.getElementById('stickerScale');
  const stickerRotate = document.getElementById('stickerRotate');
  const deleteStickerBtn = document.getElementById('deleteSticker');
  const bringForwardBtn = document.getElementById('bringForward');
  const sendBackBtn = document.getElementById('sendBack');

  const inputs = {
    wishText: document.getElementById('wishText'),
    wishColor: document.getElementById('wishColor'),
    wishSize: document.getElementById('wishSize'),
    wishFont: document.getElementById('wishFont'),
    wishRotate: document.getElementById('wishRotate'),
    wishStrokeEnable: document.getElementById('wishStrokeEnable'),
    wishStrokeColor: document.getElementById('wishStrokeColor'),
    wishStrokeWidth: document.getElementById('wishStrokeWidth'),

    subText: document.getElementById('subText'),
    subColor: document.getElementById('subColor'),
    subSize: document.getElementById('subSize'),
    subFont: document.getElementById('subFont'),
    subRotate: document.getElementById('subRotate'),
    subStrokeEnable: document.getElementById('subStrokeEnable'),
    subStrokeColor: document.getElementById('subStrokeColor'),
    subStrokeWidth: document.getElementById('subStrokeWidth'),
  };

  const undoButton = document.getElementById('undoButton');
  const resetButton = document.getElementById('resetButton');
  const saveButton = document.getElementById('saveDesign');
  const loadButton = document.getElementById('loadDesign');
  const clearSavedBtn = document.getElementById('clearSaved');
  const helpBtn = document.getElementById('helpButton');

  const webShareBtn = document.getElementById('webShareBtn');
  const waShareBtn = document.getElementById('waShareBtn');
  const fbShareBtn = document.getElementById('fbShareBtn');

  // state
  let dpr = parseFloat(window.devicePixelRatio || 1);
  let uploadedImage = new Image();
  let isImageLoaded = false;
  let activeOverlay = null;    // dom node being dragged
  let activeSticker = null;    // selected sticker layer
  let offset = { x: 0, y: 0 }; // pointer offset to center
  let historyStack = [];
  const MAX_HISTORY = 30;
  const STORAGE_KEY = 'wishweaver_saved_design_v3';
  let stickerCounter = 0;
  let lastExportDataUrl = null; // store last exported image data URL

  // helpers
  function percentOrDefault(val, def=50) {
    const n = parseFloat(val);
    return Number.isFinite(n) ? n : def;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function debounce(fn, ms=100){ let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a), ms);} }

  function swapFontClass(el, newFont) {
    const fonts = ['font-oswald','font-caveat','font-inter','font-mono'];
    fonts.forEach(f=>el.classList.remove(f));
    el.classList.add(newFont);
  }

  // update overlays (including stroke style)
  function updateTextOverlays() {
    // wish
    wishOverlay.textContent = inputs.wishText.value;
    wishOverlay.style.color = inputs.wishColor.value;
    wishOverlay.style.fontSize = inputs.wishSize.value + 'px';
    swapFontClass(wishOverlay, inputs.wishFont.value);
    wishOverlay.style.transform = `translate(-50%, -50%) rotate(${inputs.wishRotate.value}deg)`;
    applyStrokeStyleToOverlay(wishOverlay, inputs.wishStrokeEnable.checked, inputs.wishStrokeColor.value, parseFloat(inputs.wishStrokeWidth.value), parseFloat(inputs.wishSize.value));

    // sub
    const words = inputs.subText.value.trim().split(/\s+/).filter(Boolean);
    if (words.length > 20) inputs.subText.value = words.slice(0,20).join(' ');
    subOverlay.textContent = inputs.subText.value;
    subOverlay.style.color = inputs.subColor.value;
    subOverlay.style.fontSize = inputs.subSize.value + 'px';
    swapFontClass(subOverlay, inputs.subFont.value);
    subOverlay.style.transform = `translate(-50%, -50%) rotate(${inputs.subRotate.value}deg)`;
    applyStrokeStyleToOverlay(subOverlay, inputs.subStrokeEnable.checked, inputs.subStrokeColor.value, parseFloat(inputs.subStrokeWidth.value), parseFloat(inputs.subSize.value));
  }

  // Apply stroke to DOM overlay (live preview) - scaled down to avoid heavy/thick look
  function applyStrokeStyleToOverlay(el, enable, color, width, fontSizePx) {
    // derive an effective px stroke from user width and font size.
    // scale factor reduces perceived thickness; clamp to reasonable bounds.
    const base = Math.max(0, Number(width) || 0);
    // heuristic: strokePx ≈ base * (fontSize/48) * 0.6
    const strokePx = Math.max(0, Math.round(base * ( (fontSizePx || 48) / 48 ) * 0.6));
    if (enable && strokePx > 0) {
      el.style.webkitTextStroke = `${strokePx}px ${color}`;
      el.style.textStroke = `${strokePx}px ${color}`;
      // fallback: soft multi-shadow but reduced to avoid thick look
      const w = Math.max(1, strokePx);
      const shadows = [
        `-${w}px -${w}px 0 ${color}`,
        `${w}px -${w}px 0 ${color}`,
        `-${w}px ${w}px 0 ${color}`,
        `${w}px ${w}px 0 ${color}`,
      ].join(', ');
      el.style.textShadow = shadows;
    } else {
      el.style.webkitTextStroke = '';
      el.style.textStroke = '';
      el.style.textShadow = '2px 2px 4px rgba(0,0,0,0.45)';
    }
  }

  // canvas resizing (no cumulative transform)
  function resizeCanvas() {
    const cssW = previewContainer.clientWidth;
    const [w,h] = aspectRatio.value.split(':').map(Number);
    const cssH = Math.round(cssW * (h / w));
    previewContainer.style.height = cssH + 'px';
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    dpr = parseFloat(window.devicePixelRatio || 1);
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0,0,cssW,cssH);
    if (isImageLoaded) drawImageOnCanvas();
  }

  function drawImageOnCanvas() {
    if (!isImageLoaded) {
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      return;
    }
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const iw = uploadedImage.width, ih = uploadedImage.height;
    const scale = Math.max(cssW / iw, cssH / ih);
    const tW = iw * scale, tH = ih * scale;
    const x = (cssW - tW) / 2, y = (cssH - tH) / 2;
    ctx.clearRect(0,0,cssW,cssH);
    ctx.drawImage(uploadedImage, x, y, tW, tH);
  }

  // save/undo helpers
  function saveHistory(el) {
    if (!el) return;
    const snapshot = {
      id: el.id || el.dataset.layerId || null,
      type: el.classList.contains('sticker-layer') ? 'sticker' : 'text',
      top: el.style.top || '50%',
      left: el.style.left || '50%',
      transform: el.style.transform || ''
    };
    historyStack.push(snapshot);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
    undoButton.disabled = false;
  }
  function undoLastMove() {
    if (!historyStack.length) return;
    const last = historyStack.pop();
    let el = null;
    if (last.type === 'sticker') el = document.querySelector(`.sticker-layer[data-layer-id="${last.id}"]`);
    else el = document.getElementById(last.id);
    if (el) {
      el.style.top = last.top;
      el.style.left = last.left;
      el.style.transform = last.transform;
    }
    if (!historyStack.length) undoButton.disabled = true;
  }

  // reset
  function resetAll() {
    wishOverlay.style.top = '25%'; wishOverlay.style.left = '50%'; wishOverlay.style.transform = 'translate(-50%,-50%) rotate(0deg)';
    subOverlay.style.top = '80%'; subOverlay.style.left = '50%'; subOverlay.style.transform = 'translate(-50%,-50%) rotate(0deg)';
    stickerLayerContainer.innerHTML = '';
    activeSticker = null; stickerControls.classList.add('hidden');

    aspectRatio.value = '1:1';
    inputs.wishText.value = 'Happy Moments!';
    inputs.wishColor.value = '#ffffff';
    inputs.wishSize.value = 48;
    inputs.wishFont.value = 'font-oswald';
    inputs.wishRotate.value = 0;
    inputs.wishStrokeEnable.checked = false;
    inputs.wishStrokeColor.value = '#000000';
    inputs.wishStrokeWidth.value = 2;

    inputs.subText.value = 'Wishing you a wonderful day filled with joy and laughter!';
    inputs.subColor.value = '#facc15';
    inputs.subSize.value = 20;
    inputs.subFont.value = 'font-inter';
    inputs.subRotate.value = 0;
    inputs.subStrokeEnable.checked = false;
    inputs.subStrokeColor.value = '#000000';
    inputs.subStrokeWidth.value = 1;

    updateTextOverlays();
    historyStack = [];
    undoButton.disabled = true;

    uploadedImage = new Image();
    isImageLoaded = false;
    imageUpload.value = '';
    imagePlaceholder.style.display = 'flex';
    generateButton.disabled = true;
    generateButton.style.pointerEvents = 'none';

    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    outputArea.classList.add('hidden');
    finalImagePreview.style.display = 'none';
    downloadLink.href = '';

    resizeCanvas();
  }

  // sticker creation
  function addSticker(src, left='50%', top='50%', scale=1, rotate=0) {
    const id = 'sticker_' + (++stickerCounter);
    const el = document.createElement('div');
    el.className = 'sticker-layer';
    el.dataset.layerId = id;
    el.style.left = left;
    el.style.top = top;
    el.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${rotate}deg)`;
    el.setAttribute('tabindex', '0');

    const img = document.createElement('img');
    img.src = src;
    img.alt = 'sticker';
    img.style.width = '96px';
    img.style.height = 'auto';
    el.appendChild(img);

    stickerLayerContainer.appendChild(el);
    selectSticker(el);
    return el;
  }

  function selectSticker(el) {
    if (activeSticker) activeSticker.classList.remove('selected');
    activeSticker = el;
    if (!el) { stickerControls.classList.add('hidden'); return; }
    el.classList.add('selected');
    const m = el.style.transform.match(/scale\((-?[0-9.]+)\)\s*rotate\((-?[0-9.]+)deg\)/);
    const scale = m ? parseFloat(m[1]) : 1;
    const rotate = m ? parseFloat(m[2]) : 0;
    stickerScale.value = scale;
    stickerRotate.value = rotate;
    stickerControls.classList.remove('hidden');
  }

  // sticker control handlers
  stickerScale.addEventListener('input', () => {
    if (!activeSticker) return;
    const s = parseFloat(stickerScale.value);
    const r = parseFloat(stickerRotate.value);
    activeSticker.style.transform = `translate(-50%, -50%) scale(${s}) rotate(${r}deg)`;
  });
  stickerRotate.addEventListener('input', () => {
    if (!activeSticker) return;
    const s = parseFloat(stickerScale.value);
    const r = parseFloat(stickerRotate.value);
    activeSticker.style.transform = `translate(-50%, -50%) scale(${s}) rotate(${r}deg)`;
  });
  bringForwardBtn.addEventListener('click', () => {
    if (!activeSticker) return;
    const z = parseInt(activeSticker.style.zIndex || 3);
    activeSticker.style.zIndex = z + 1;
  });
  sendBackBtn.addEventListener('click', () => {
    if (!activeSticker) return;
    const z = parseInt(activeSticker.style.zIndex || 3);
    activeSticker.style.zIndex = Math.max(0, z - 1);
  });
  deleteStickerBtn.addEventListener('click', () => {
    if (!activeSticker) return;
    activeSticker.remove();
    activeSticker = null;
    stickerControls.classList.add('hidden');
  });

  // sticker palette click
  document.querySelectorAll('#stickerPalette .sticker-thumb').forEach(btn => {
    btn.addEventListener('click', () => {
      const src = btn.dataset.src;
      const existing = stickerLayerContainer.children.length;
      const left = 50 + (existing % 5) * 6;
      const top = 50 + Math.floor(existing / 5) * 6;
      const st = addSticker(src, left + '%', top + '%', 1, 0);
      selectSticker(st);
    });
  });

  // pointer handlers for dragging text and stickers
  function getPointerCoords(e) { return { x: e.clientX ?? 0, y: e.clientY ?? 0 }; }

  function pointerDownHandler(e) {
    if (e.button !== undefined && e.button !== 0) return;
    let target = e.target;
    if (target.closest && target.closest('.sticker-layer')) target = target.closest('.sticker-layer');
    if (!target) return;
    if (target.classList.contains('draggable-text') || target.classList.contains('sticker-layer')) {
      e.preventDefault();
      activeOverlay = target;
      saveHistory(activeOverlay);
      if (activeOverlay.classList.contains('sticker-layer')) selectSticker(activeOverlay);
      else { if (activeSticker) { activeSticker.classList.remove('selected'); activeSticker = null; stickerControls.classList.add('hidden'); } }
      const parentRect = previewContainer.getBoundingClientRect();
      const leftPercent = percentOrDefault(activeOverlay.style.left, 50);
      const topPercent = percentOrDefault(activeOverlay.style.top, 50);
      const centerX = parentRect.left + parentRect.width * leftPercent / 100;
      const centerY = parentRect.top + parentRect.height * topPercent / 100;
      const { x, y } = getPointerCoords(e);
      offset.x = x - centerX;
      offset.y = y - centerY;
      try { activeOverlay.setPointerCapture?.(e.pointerId); } catch(err) {}
      activeOverlay.style.zIndex = 99;
    } else {
      if (activeSticker) { activeSticker.classList.remove('selected'); activeSticker = null; stickerControls.classList.add('hidden'); }
    }
  }

  function pointerMoveHandler(e) {
    if (!activeOverlay) return;
    e.preventDefault();
    const parentRect = previewContainer.getBoundingClientRect();
    const { x, y } = getPointerCoords(e);
    const newCenterX = x - offset.x;
    const newCenterY = y - offset.y;
    let leftPct = ((newCenterX - parentRect.left) / parentRect.width) * 100;
    let topPct = ((newCenterY - parentRect.top) / parentRect.height) * 100;
    leftPct = clamp(leftPct, 0, 100);
    topPct = clamp(topPct, 0, 100);
    activeOverlay.style.left = leftPct.toFixed(2) + '%';
    activeOverlay.style.top = topPct.toFixed(2) + '%';
  }

  function pointerUpHandler(e) {
    if (!activeOverlay) return;
    try { activeOverlay.releasePointerCapture?.(e.pointerId); } catch(err) {}
    activeOverlay.style.zIndex = '';
    activeOverlay = null;
  }

  // keyboard nudging for overlays
  function overlayKeyHandler(e) {
    const el = e.currentTarget;
    const step = e.shiftKey ? 10 : 1;
    let left = percentOrDefault(el.style.left, 50);
    let top = percentOrDefault(el.style.top, 50);
    let moved = false;
    if (e.key === 'ArrowLeft') { left -= (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowRight') { left += (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowUp') { top -= (step / (previewContainer.clientHeight/100)); moved=true; }
    if (e.key === 'ArrowDown') { top += (step / (previewContainer.clientHeight/100)); moved=true; }
    if (moved) {
      e.preventDefault();
      saveHistory(el);
      el.style.left = clamp(left,0,100).toFixed(2) + '%';
      el.style.top = clamp(top,0,100).toFixed(2) + '%';
      undoButton.disabled = false;
      drawImageOnCanvas();
    }
  }

  wishOverlay.addEventListener('keydown', overlayKeyHandler);
  subOverlay.addEventListener('keydown', overlayKeyHandler);

  document.addEventListener('pointerdown', pointerDownHandler);
  document.addEventListener('pointermove', pointerMoveHandler, { passive:false });
  document.addEventListener('pointerup', pointerUpHandler);

  // image upload
  imageUpload.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    if (file.size > 8 * 1024 * 1024) {
      fileWarn.textContent = 'Large image detected (>8MB). Upload may be slow; consider a smaller image.';
      fileWarn.classList.remove('hidden');
    } else fileWarn.classList.add('hidden');

    const reader = new FileReader();
    reader.onload = function(evt) {
      uploadedImage = new Image();
      uploadedImage.onload = function() {
        isImageLoaded = true;
        imagePlaceholder.style.display = 'none';
        // **ensure generate button is enabled and clickable immediately**
        generateButton.disabled = false;
        generateButton.style.pointerEvents = 'auto';
        resizeCanvas();
        drawImageOnCanvas();
      };
      uploadedImage.onerror = function() { console.error('Image load error'); };
      uploadedImage.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  });

  // export / generate final PNG
  function generateFinalImage() {
    if (!isImageLoaded) return;
    const exportScale = parseFloat(exportDpr.value) || 2;
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = Math.round(cssW * exportScale);
    exportCanvas.height = Math.round(cssH * exportScale);
    const ectx = exportCanvas.getContext('2d', { alpha: false });
    ectx.setTransform(exportScale, 0, 0, exportScale, 0, 0);

    // draw background image center-crop
    const iw = uploadedImage.width, ih = uploadedImage.height;
    const scale = Math.max(cssW / iw, cssH / ih);
    const tW = iw * scale, tH = ih * scale;
    const x = (cssW - tW) / 2, y = (cssH - tH) / 2;
    ectx.clearRect(0,0,cssW,cssH);
    ectx.drawImage(uploadedImage, x, y, tW, tH);

    // draw stickers
    const stickerEls = Array.from(stickerLayerContainer.children);
    stickerEls.sort((a,b) => (parseInt(a.style.zIndex||3) - parseInt(b.style.zIndex||3)));
    stickerEls.forEach(el => {
      drawStickerOnExportCtx(ectx, el);
    });

    // draw texts with stroke scaled down further for export
    drawTextOnExportCtx(ectx, wishOverlay, {
      text: inputs.wishText.value,
      color: inputs.wishColor.value,
      fontSize: parseFloat(inputs.wishSize.value),
      fontClass: inputs.wishFont.value,
      rotateDeg: parseFloat(inputs.wishRotate.value),
      strokeEnable: inputs.wishStrokeEnable.checked,
      strokeColor: inputs.wishStrokeColor.value,
      strokeWidth: parseFloat(inputs.wishStrokeWidth.value)
    });
    drawTextOnExportCtx(ectx, subOverlay, {
      text: inputs.subText.value,
      color: inputs.subColor.value,
      fontSize: parseFloat(inputs.subSize.value),
      fontClass: inputs.subFont.value,
      rotateDeg: parseFloat(inputs.subRotate.value),
      strokeEnable: inputs.subStrokeEnable.checked,
      strokeColor: inputs.subStrokeColor.value,
      strokeWidth: parseFloat(inputs.subStrokeWidth.value)
    });

    // watermark
    try {
      const watermarkText = 'designed by weaver';
      const fontSize = Math.max(12, Math.round(cssW * 0.03));
      ectx.save();
      ectx.globalAlpha = 0.55;
      ectx.font = `${fontSize}px Inter`;
      ectx.textAlign = 'center';
      ectx.textBaseline = 'bottom';
      ectx.lineWidth = Math.max(1, Math.round(fontSize * 0.08));
      ectx.strokeStyle = 'rgba(0,0,0,0.35)';
      ectx.strokeText(watermarkText, cssW / 2, cssH - Math.round(fontSize * 0.25));
      ectx.fillStyle = 'rgba(255,255,255,0.95)';
      ectx.fillText(watermarkText, cssW / 2, cssH - Math.round(fontSize * 0.25));
      ectx.restore();
    } catch (err) { console.warn('Watermark draw failed', err); }

    const dataUrl = exportCanvas.toDataURL('image/png');
    lastExportDataUrl = dataUrl;
    finalImagePreview.src = dataUrl;
    finalImagePreview.style.display = 'block';
    downloadLink.href = dataUrl;
    downloadLink.download = 'wishweaver-card.png';
    outputArea.classList.remove('hidden');
    finalImagePreview.scrollIntoView({ behavior: 'smooth' });
  }

  function drawTextOnExportCtx(ectx, el, options) {
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const left = percentOrDefault(el.style.left,50);
    const top = percentOrDefault(el.style.top,50);
    const x = (left/100) * cssW;
    const y = (top/100) * cssH;
    const fontSize = options.fontSize || parseFloat(window.getComputedStyle(el).fontSize) || 24;
    let family = 'Inter';
    if ((options.fontClass||'').includes('oswald')) family='Oswald';
    else if ((options.fontClass||'').includes('caveat')) family='Caveat';
    else if ((options.fontClass||'').includes('mono')) family='Roboto Mono';

    ectx.save();
    ectx.translate(x,y);
    ectx.rotate((options.rotateDeg||0) * Math.PI/180);
    ectx.font = `${fontSize}px ${family}`;
    ectx.textAlign = 'center';
    ectx.textBaseline = 'middle';

    // scale stroke for export: use a conservative multiplier to avoid heavy stroke
    const baseStroke = Math.max(0, Number(options.strokeWidth) || 0);
    const strokeExportPx = Math.max(0, baseStroke * 0.6); // reduced from user input
    if (options.strokeEnable && strokeExportPx > 0) {
      ectx.lineWidth = Math.max(1, strokeExportPx);
      ectx.strokeStyle = options.strokeColor||'#000';
      ectx.strokeText(options.text,0,0);
    }
    ectx.fillStyle = options.color||'#fff';
    ectx.fillText(options.text,0,0);
    ectx.restore();
  }

  function drawStickerOnExportCtx(ectx, el) {
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const left = percentOrDefault(el.style.left,50);
    const top = percentOrDefault(el.style.top,50);
    const x = (left/100) * cssW;
    const y = (top/100) * cssH;

    const tr = el.style.transform || '';
    const m = tr.match(/scale\((-?[0-9.]+)\)\s*rotate\((-?[0-9.]+)deg\)/);
    const scale = m ? parseFloat(m[1]) : 1;
    const rotate = m ? parseFloat(m[2]) : 0;
    const img = el.querySelector('img');
    if (!img || !img.naturalWidth) return;

    const cssImgWidth = parseFloat(img.style.width) || (img.naturalWidth * 0.15);
    const cssImgHeight = cssImgWidth * (img.naturalHeight / img.naturalWidth);

    ectx.save();
    ectx.translate(x, y);
    ectx.rotate(rotate * Math.PI/180);
    ectx.scale(scale, scale);
    ectx.drawImage(img, -cssImgWidth/2, -cssImgHeight/2, cssImgWidth, cssImgHeight);
    ectx.restore();
  }

  // events wiring
  aspectRatio.addEventListener('change', () => { resizeCanvas(); });
  window.addEventListener('resize', debounce(()=> { resizeCanvas(); }, 120));
  Object.values(inputs).forEach(inp => { inp.addEventListener('input', () => { updateTextOverlays(); if (isImageLoaded) drawImageOnCanvas(); }); });

  stickerLayerContainer.addEventListener('pointerdown', (ev) => {
    const st = ev.target.closest && ev.target.closest('.sticker-layer');
    if (st) selectSticker(st);
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && activeSticker) {
      activeSticker.remove();
      activeSticker = null;
      stickerControls.classList.add('hidden');
    }
  });

  // Save / Load designs
  saveButton.addEventListener('click', () => {
    const stickerNodes = Array.from(stickerLayerContainer.children).map(el => {
      const img = el.querySelector('img');
      const left = el.style.left || '50%';
      const top = el.style.top || '50%';
      const tr = el.style.transform || '';
      const m = tr.match(/scale\((-?[0-9.]+)\)\s*rotate\((-?[0-9.]+)deg\)/);
      const scale = m ? parseFloat(m[1]) : 1;
      const rotate = m ? parseFloat(m[2]) : 0;
      const z = el.style.zIndex || 3;
      return { src: img.src, left, top, scale, rotate, z };
    });
    const state = {
      imageDataUrl: uploadedImage && uploadedImage.src ? uploadedImage.src : null,
      aspectRatio: aspectRatio.value,
      wish: {
        text: inputs.wishText.value,
        color: inputs.wishColor.value,
        size: inputs.wishSize.value,
        font: inputs.wishFont.value,
        rotate: inputs.wishRotate.value,
        strokeEnable: inputs.wishStrokeEnable.checked,
        strokeColor: inputs.wishStrokeColor.value,
        strokeWidth: inputs.wishStrokeWidth.value,
        top: wishOverlay.style.top || '25%',
        left: wishOverlay.style.left || '50%',
        transform: wishOverlay.style.transform || ''
      },
      sub: {
        text: inputs.subText.value,
        color: inputs.subColor.value,
        size: inputs.subSize.value,
        font: inputs.subFont.value,
        rotate: inputs.subRotate.value,
        strokeEnable: inputs.subStrokeEnable.checked,
        strokeColor: inputs.subStrokeColor.value,
        strokeWidth: inputs.subStrokeWidth.value,
        top: subOverlay.style.top || '80%',
        left: subOverlay.style.left || '50%',
        transform: subOverlay.style.transform || ''
      },
      stickers: stickerNodes
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    alert('Design saved locally in your browser.');
  });

  loadButton.addEventListener('click', () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) { alert('No saved design found.'); return; }
    try {
      const st = JSON.parse(raw);
      if (st.imageDataUrl) {
        uploadedImage = new Image();
        uploadedImage.onload = () => { isImageLoaded = true; imagePlaceholder.style.display='none'; generateButton.disabled = false; generateButton.style.pointerEvents = 'auto'; resizeCanvas(); drawImageOnCanvas(); };
        uploadedImage.src = st.imageDataUrl;
      }
      if (st.aspectRatio) aspectRatio.value = st.aspectRatio;
      if (st.wish) {
        inputs.wishText.value = st.wish.text || inputs.wishText.value;
        inputs.wishColor.value = st.wish.color || inputs.wishColor.value;
        inputs.wishSize.value = st.wish.size || inputs.wishSize.value;
        inputs.wishFont.value = st.wish.font || inputs.wishFont.value;
        inputs.wishRotate.value = st.wish.rotate || inputs.wishRotate.value;
        inputs.wishStrokeEnable.checked = st.wish.strokeEnable || false;
        inputs.wishStrokeColor.value = st.wish.strokeColor || inputs.wishStrokeColor.value;
        inputs.wishStrokeWidth.value = st.wish.strokeWidth || inputs.wishStrokeWidth.value;
        wishOverlay.style.top = st.wish.top || wishOverlay.style.top;
        wishOverlay.style.left = st.wish.left || wishOverlay.style.left;
        wishOverlay.style.transform = st.wish.transform || wishOverlay.style.transform;
      }
      if (st.sub) {
        inputs.subText.value = st.sub.text || inputs.subText.value;
        inputs.subColor.value = st.sub.color || inputs.subColor.value;
        inputs.subSize.value = st.sub.size || inputs.subSize.value;
        inputs.subFont.value = st.sub.font || inputs.subFont.value;
        inputs.subRotate.value = st.sub.rotate || inputs.subRotate.value;
        inputs.subStrokeEnable.checked = st.sub.strokeEnable || false;
        inputs.subStrokeColor.value = st.sub.strokeColor || inputs.subStrokeColor.value;
        inputs.subStrokeWidth.value = st.sub.strokeWidth || inputs.subStrokeWidth.value;
        subOverlay.style.top = st.sub.top || subOverlay.style.top;
        subOverlay.style.left = st.sub.left || subOverlay.style.left;
        subOverlay.style.transform = st.sub.transform || subOverlay.style.transform;
      }
      stickerLayerContainer.innerHTML = '';
      if (st.stickers && Array.isArray(st.stickers)) {
        st.stickers.forEach(s => {
          const el = addSticker(s.src, s.left, s.top, s.scale, s.rotate);
          el.style.zIndex = s.z || 3;
        });
      }
      updateTextOverlays();
      resizeCanvas();
      alert('Design loaded.');
    } catch (err) {
      console.error(err);
      alert('Failed to load saved design.');
    }
  });

  clearSavedBtn.addEventListener('click', () => {
    localStorage.removeItem(STORAGE_KEY);
    alert('Saved design cleared.');
  });

  helpBtn.addEventListener('click', () => {
    const msg = `Use Wish Weaver:\n\n1. Upload an image.\n2. Choose aspect ratio and DPI.\n3. Edit main and sub text, pick fonts, rotate, and add optional stroke.\n4. Add stickers from the picker (click to add). Select stickers to scale/rotate/delete.\n5. Drag text and stickers to position. Use arrow keys to nudge (Shift for larger steps).\n6. Click "GENERATE SHARABLE CARD" to export and get a downloadable PNG. All processing happens locally in your browser.`;
    alert(msg);
  });

  // enable generate when image loaded
  function updateButtonsState() {
    undoButton.disabled = historyStack.length === 0;
    generateButton.disabled = !isImageLoaded;
    if (isImageLoaded) generateButton.style.pointerEvents = 'auto';
    else generateButton.style.pointerEvents = 'none';
  }
  setInterval(updateButtonsState, 400);

  // attach small keyboard handler for sticker container (nudge)
  stickerLayerContainer.addEventListener('keydown', (e) => {
    if (e.target && e.target.classList.contains('sticker-layer')) overlayKeyHandler.call(e.target, e);
  });

  function overlayKeyHandler(e) {
    const el = e.currentTarget;
    const step = e.shiftKey ? 10 : 1;
    let left = percentOrDefault(el.style.left,50);
    let top = percentOrDefault(el.style.top,50);
    let moved = false;
    if (e.key === 'ArrowLeft') { left -= (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowRight') { left += (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowUp') { top -= (step / (previewContainer.clientHeight/100)); moved=true; }
    if (e.key === 'ArrowDown') { top += (step / (previewContainer.clientHeight/100)); moved=true; }
    if (moved) {
      e.preventDefault();
      saveHistory(el);
      el.style.left = clamp(left,0,100).toFixed(02)+'%';
      el.style.top = clamp(top,0,100).toFixed(02)+'%';
      undoButton.disabled = false;
    }
  }

  // generate button click wiring - robust handler
  function handleGenerateClick(e) {
    e?.preventDefault?.();
    // If generateButton is disabled, give a small feedback
    if (generateButton.disabled || !isImageLoaded) {
      // brief flash to show disabled state
      generateButton.classList.add('opacity-70');
      setTimeout(()=> generateButton.classList.remove('opacity-70'), 160);
      if (!isImageLoaded) alert('Please upload an image first.');
      return;
    }
    // Visual feedback
    const prevText = generateButton.textContent;
    generateButton.disabled = true;
    generateButton.textContent = 'Generating…';
    setTimeout(() => {
      try {
        generateFinalImage();
      } finally {
        generateButton.textContent = prevText || 'GENERATE SHARABLE CARD';
        generateButton.disabled = !isImageLoaded;
      }
    }, 80);
  }

  // reset & undo hooks
  resetButton.addEventListener('click', resetAll);
  undoButton.addEventListener('click', undoLastMove);

  // initial setup
  updateTextOverlays();
  resizeCanvas();
  generateButton.disabled = true;
  generateButton.style.pointerEvents = 'none';

  // Sharing logic
  async function dataURLtoBlob(dataurl) {
    const res = await fetch(dataurl);
    const blob = await res.blob();
    return blob;
  }

  webShareBtn.addEventListener('click', async () => {
    if (!lastExportDataUrl) { alert('Please generate the card first.'); return; }
    if (navigator.canShare && navigator.canShare({ files: [] })) {
      try {
        const blob = await dataURLtoBlob(lastExportDataUrl);
        const file = new File([blob], 'wishweaver-card.png', { type: 'image/png' });
        await navigator.share({
          files: [file],
          title: 'My Wish Weaver Card',
          text: 'Hey — check out this card I made with Wish Weaver.'
        });
      } catch (err) {
        console.error('Web share failed', err);
        alert('Sharing failed (browser may not support sharing files). You can still download and share manually.');
      }
    } else if (navigator.share) {
      try {
        await navigator.share({ title: 'Wish Weaver', text: 'I made this card with Wish Weaver — download and view.', url: lastExportDataUrl });
      } catch (err) {
        console.error('Web share fallback failed', err);
        alert('Sharing not supported in this browser. Please download and share manually.');
      }
    } else {
      alert('Your browser does not support direct web sharing. Please download the image and share manually to social apps.');
    }
  });

  waShareBtn.addEventListener('click', () => {
    if (!lastExportDataUrl) { alert('Please generate the card first.'); return; }
    const text = encodeURIComponent('Check out my card I made with Wish Weaver:');
    const url = `https://wa.me/?text=${text}%0A${encodeURIComponent(lastExportDataUrl)}`;
    window.open(url, '_blank');
  });

  fbShareBtn.addEventListener('click', () => {
    if (!lastExportDataUrl) { alert('Please generate the card first.'); return; }
    const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(lastExportDataUrl)}`;
    window.open(fbUrl, '_blank');
  });

  // Done.
  </script>
</body>
</html>
