<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Google Search Console Verification -->
  <meta name="google-site-verification" content="6j0L0k_Q87IrGERn1dMLVxmJJXiKiHwG9ivNHjcwahY" />
  <title>Wish Weaver ‚Äî Digital Card Creator</title>
  <!-- Open Graph (Facebook / WhatsApp / LinkedIn) -->
<!-- Open Graph (Facebook / WhatsApp / LinkedIn) -->
<meta property="og:type" content="website" />
<meta property="og:title" content="Wish Weaver ‚Äî Create beautiful shareable cards" />
<meta property="og:description" content="Make and share custom greeting cards in your browser. No uploads ‚Äî everything stays on your device." />
<meta property="og:url" content="https://talewinds.github.io/WEAVER/" />
<meta property="og:image" content="https://talewinds.github.io/WEAVER/social/og-image-1200x630.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Wish Weaver ‚Äî Create beautiful shareable cards" />
<meta name="twitter:description" content="Make and share custom greeting cards directly from your browser." />
<meta name="twitter:image" content="https://talewinds.github.io/WEAVER/social/og-image-1200x630.png" />

  <meta name="description" content="Wish Weaver ‚Äî Create beautiful shareable cards in your browser. Local processing. Add stickers, custom text, rotate, scale, and export high-resolution PNGs." />
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Oswald:wght@400;700&family=Caveat:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    .font-inter { font-family: 'Inter', sans-serif; }
    .font-oswald { font-family: 'Oswald', sans-serif; }
    .font-caveat { font-family: 'Caveat', cursive; }
    .font-mono { font-family: 'Roboto Mono', monospace; }

    .draggable-text {
      position: absolute;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
      padding: 6px 10px;
      border: 2px dashed rgba(255,255,255,0.5);
      transform: translate(-50%, -50%);
      transition: opacity 0.15s, transform 0.1s;
      max-width: 90%;
      overflow-wrap: break-word;
      z-index: 5;
      touch-action: none;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.45);
    }
    .draggable-text:active { cursor: grabbing; }

    /* sticker layer (now holds emoji text) */
    .sticker-layer {
      position: absolute;
      touch-action: none;
      transform-origin: center center;
      z-index: 3;
      user-select: none;
      -webkit-user-select: none;
      cursor: grab;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .sticker-layer .emoji {
      pointer-events: none;
      display:inline-block;
      line-height:1;
      user-select:none;
      -webkit-user-select:none;
      transform-origin:center center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.45);
    }

    #previewContainer { touch-action: none; }

    .draggable-text:focus, .sticker-layer:focus { outline: 2px dashed rgba(30,64,175,0.85); outline-offset: 6px; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
    ::-webkit-scrollbar-track { background: #f0f4f8; }

    /* sticker thumbnail style */
    .sticker-thumb img, .sticker-thumb .emoji { display:block; width:100%; height:100%; object-fit:contain; text-align:center; }

    /* Ad placeholders */
    .adsense-placeholder {
      min-height: 90px;
      border: 2px dashed #34d399;
      background-color: #e0fcf4;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#065f46;
      font-weight:600;
      border-radius:10px;
      text-align:center;
    }
    .adsense-small { min-height:60px; }
    .adsense-rect { min-height:120px; }

    /* nicer upload placeholder background & watermark link style */
    #imagePlaceholder {
      background: linear-gradient(135deg, #fbf8ff 0%, #f6fbff 50%, #fff8f5 100%);
      color: #374151;
      gap: 8px;
    }
    /* clickable watermark overlay inside preview */
    #previewWatermark {
      position: absolute;
      left: 50%;
      bottom: 6px;
      transform: translateX(-50%);
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.5);
      color: #0b3b73;
      text-decoration: underline;
      cursor: pointer;
      z-index: 60;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      pointer-events: auto;
    }
    #previewWatermark:hover { background: rgba(255,255,255,0.75); }

    /* output watermark overlay */
    #outputArea { position: relative; }
    #outputWatermark {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 12px;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.6);
      color: #0b3b73;
      text-decoration: underline;
      cursor: pointer;
      z-index: 999;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      pointer-events: auto;
      display: none;
    }
    #outputWatermark:hover { background: rgba(255,255,255,0.85); }

    /* ensure watermark is clickable above image */
    #finalImagePreview { position: relative; z-index: 1; }
  </style>
</head>
<body class="bg-gray-50 font-inter text-gray-800 min-h-screen flex flex-col">

  <!-- Header -->
  <header class="bg-blue-900 text-white">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
      <h1 class="text-2xl font-bold"><span class="text-yellow-300">W</span>ish <span class="text-yellow-300">W</span>eaver</h1>
      <div class="flex items-center gap-3">
        <button id="helpButton" class="bg-yellow-300 text-blue-900 px-3 py-2 rounded-full font-semibold">How to Use</button>
        <button id="saveDesign" class="bg-emerald-500 text-white px-3 py-2 rounded-md">Save</button>
        <button id="loadDesign" class="bg-gray-200 text-gray-800 px-3 py-2 rounded-md">Load</button>
        <button id="clearSaved" class="bg-red-100 text-red-700 px-3 py-2 rounded-md">Clear Saved</button>
      </div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-6xl mx-auto w-full flex-grow grid lg:grid-cols-3 gap-8 p-6">

    <!-- Left Column: Controls -->
    <section class="lg:col-span-1 space-y-6">

      <!-- Ad slot (top) -->
      <div class="adsense-placeholder adsense-small">
        Ad placeholder ‚Äî Leaderboard / AdSense (300x100). Replace with AdSense code.
      </div>

      <div class="p-6 bg-white rounded-xl shadow">
        <h2 class="font-bold text-lg text-blue-800 mb-3">1. Choose Canvas</h2>
        <input id="imageUpload" type="file" accept="image/*" aria-label="Upload image" class="w-full text-sm" />
        <p id="fileWarn" class="text-sm text-red-600 mt-2 hidden"></p>
        <div class="mt-4">
          <label class="block text-sm mb-1">Aspect Ratio</label>
          <select id="aspectRatio" class="w-full p-2 rounded border">
            <option value="1:1">Square ‚Äî 1:1</option>
            <option value="4:5">Portrait ‚Äî 4:5 (Instagram)</option>
            <option value="9:16">Story ‚Äî 9:16</option>
          </select>
        </div>
        <div class="mt-4">
          <label class="block text-sm mb-1">Export DPI</label>
          <select id="exportDpr" class="w-full p-2 rounded border">
            <option value="1">1x (normal)</option>
            <option value="2" selected>2x (retina)</option>
            <option value="3">3x (very high)</option>
          </select>
        </div>
      </div>

      <!-- Text Customization -->
      <div class="p-6 bg-white rounded-xl shadow space-y-4">
        <h2 class="font-bold text-lg text-blue-800">2. Customize Text</h2>

        <div>
          <label class="text-sm block mb-1">Main Wish</label>
          <textarea id="wishText" class="w-full p-2 border rounded resize-y h-20" maxlength="300" rows="3" placeholder="Type your wish ‚Äî press Enter for new line">Happy Moments!</textarea>
          <div class="flex items-center gap-2 mt-2">
            <input id="wishColor" type="color" value="#ffffff" title="Wish color" />
            <input id="wishSize" type="number" min="14" max="200" value="48" class="w-20 p-1 border rounded text-center" title="Font size" />
            <select id="wishFont" class="flex-1 p-1 border rounded">
              <option value="font-oswald">Oswald (Bold)</option>
              <option value="font-caveat">Caveat (Cursive)</option>
              <option value="font-inter" selected>Inter (Modern)</option>
              <option value="font-mono">Roboto Mono</option>
            </select>
          </div>
          <div class="mt-2 flex items-center gap-2 text-sm">
            <label class="flex items-center gap-1"><input id="wishStrokeEnable" type="checkbox" /> Stroke</label>
            <input id="wishStrokeColor" type="color" value="#000000" />
            <input id="wishStrokeWidth" type="number" min="0" max="20" value="2" class="w-20 p-1 border rounded text-center" />
            <label class="ml-auto text-xs text-gray-500">Rotate:</label>
            <input id="wishRotate" type="range" min="-180" max="180" value="0" class="w-32" />
          </div>
        </div>

        <div>
          <label class="text-sm block mb-1">Sub Text (max 20 words)</label>
          <textarea id="subText" class="w-full p-2 border rounded" rows="2">Wishing you a wonderful day filled with joy and laughter!</textarea>
          <div class="flex items-center gap-2 mt-2">
            <input id="subColor" type="color" value="#facc15" />
            <input id="subSize" type="number" min="10" max="120" value="20" class="w-20 p-1 border rounded text-center" />
            <select id="subFont" class="flex-1 p-1 border rounded">
              <option value="font-inter">Inter</option>
              <option value="font-oswald">Oswald</option>
              <option value="font-caveat">Caveat</option>
              <option value="font-mono">Roboto Mono</option>
            </select>
          </div>
          <div class="mt-2 flex items-center gap-2 text-sm">
            <label class="flex items-center gap-1"><input id="subStrokeEnable" type="checkbox" /> Stroke</label>
            <input id="subStrokeColor" type="color" value="#000000" />
            <input id="subStrokeWidth" type="number" min="0" max="20" value="1" class="w-20 p-1 border rounded text-center" />
            <label class="ml-auto text-xs text-gray-500">Rotate:</label>
            <input id="subRotate" type="range" min="-180" max="180" value="0" class="w-32" />
          </div>
        </div>
      </div>

      <!-- Sticker Picker -->
      <div class="p-6 bg-white rounded-xl shadow">
        <h2 class="font-bold text-lg text-blue-800 mb-3">3. Stickers</h2>
        <p class="text-sm text-gray-600 mb-2">Click a sticker to add it to the canvas.</p>
        <div id="stickerPalette" class="grid grid-cols-4 gap-2">
          <!-- Use emoji-based stickers (no cross-origin images) -->
          <button class="sticker-thumb p-1 bg-white rounded border" data-emoji="üéâ"><div class="emoji" style="font-size:28px; text-align:center;">üéâ</div></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-emoji="üéÅ"><div class="emoji" style="font-size:28px; text-align:center;">üéÅ</div></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-emoji="üç∞"><div class="emoji" style="font-size:28px; text-align:center;">üç∞</div></button>
          <button class="sticker-thumb p-1 bg-white rounded border" data-emoji="üíñ"><div class="emoji" style="font-size:28px; text-align:center;">üíñ</div></button>
        </div>

        <!-- Ad placeholder between sticker picker and sticker area -->
        <div class="mt-3 adsense-placeholder adsense-rect">
          Ad placeholder ‚Äî Rectangle (replace with AdSense code)
        </div>

        <!-- NOTE: sticker controls removed as requested -->
      </div>

      <!-- Quick Actions - REMOVED the writeup as requested (kept empty container to avoid layout shifts) -->
      <div class="p-6 bg-white rounded-xl shadow flex flex-col gap-3">
        <!-- intentionally left blank per request -->
      </div>
    </section>

    <!-- Right Column: Preview & Output -->
    <section class="lg:col-span-2">
      <div class="bg-white rounded-xl shadow p-4">
        <h2 class="font-bold text-lg text-green-700 mb-3">Live Preview</h2>

        <div id="previewContainer" class="relative mx-auto overflow-hidden rounded-lg bg-gray-200 border-4 border-blue-800 max-w-2xl" style="aspect-ratio: 1 / 1; width:100%;">
          <canvas id="cardCanvas" class="w-full h-full"></canvas>

          <!-- Text overlays -->
          <div id="wishOverlay" class="draggable-text font-oswald text-white" tabindex="0"
               style="top:25%; left:50%; font-size:48px; transform: translate(-50%, -50%) rotate(0deg);">
            Happy Moments!
          </div>

          <div id="subOverlay" class="draggable-text font-inter text-yellow-300" tabindex="0"
               style="top:80%; left:50%; font-size:20px; transform: translate(-50%, -50%) rotate(0deg);">
            Wishing you a wonderful day filled with joy and laughter!
          </div>

          <!-- Sticker container (DOM overlays) -->
          <div id="stickerLayerContainer"></div>

          <div id="imagePlaceholder" class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 pointer-events-none">
            <svg class="w-16 h-16 mb-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 003-2V6a2 2 0 00-2-2H6"></path></svg>
            <p class="text-lg font-semibold">Upload an image to start</p>
          </div>

          <!-- Clickable watermark overlay (bottom-center, clickable) -->
          <a id="previewWatermark" href="https://weaver.example.com" target="_blank" rel="noopener">designed by weaver</a>
        </div>

        <!-- Buttons moved to below the uploaded picture, just above the ad -->
        <div class="mt-4 flex gap-3 items-center justify-center">
          <button id="resetButton" class="px-4 py-2 rounded bg-gray-200">Reset All</button>
          <button id="undoButton" class="px-4 py-2 rounded bg-yellow-400 disabled:opacity-50" disabled>Undo</button>
          <button id="generateButton" onclick="handleGenerateClick(event)" class="px-4 py-2 rounded bg-green-600 text-white disabled:opacity-50" disabled>GENERATE SHARABLE CARD</button>
        </div>

        <!-- Ad slot below preview (responsive) -->
        <div class="mt-4 adsense-placeholder">
          Ad placeholder ‚Äî Responsive (replace with AdSense code)
        </div>

        <!-- Output -->
        <div id="outputArea" class="mt-6 hidden bg-gray-50 p-4 rounded text-center">
          <p class="font-semibold text-blue-700">Your card is ready</p>
          <div class="mt-3 flex justify-center gap-3">
            <a id="downloadLink" class="inline-flex items-center gap-2 px-4 py-2 bg-blue-700 text-white rounded" download="wishweaver-card.png">Download PNG</a>
            <button id="shareButton" class="inline-flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded">Share Card</button>
          </div>

          <!-- generated preview -->
          <div class="mt-4 relative inline-block">
            <img id="finalImagePreview" class="mx-auto mt-4 rounded shadow max-w-sm" alt="Final card" style="display:none;" />
            <!-- clickable watermark overlay inside output area (on top of the image) -->
            <a id="outputWatermark" href="https://weaver.example.com" target="_blank" rel="noopener">designed by weaver</a>
          </div>
        </div>
      </div>
    </section>

  </main>

  <!-- Footer with SEO + Privacy + designed-by link -->
  <!-- START: Footer (replace the old footer with this block) -->
<footer class="bg-white mt-8 py-8 px-6">
  <div class="max-w-6xl mx-auto grid md:grid-cols-3 gap-8 text-sm text-gray-600">
    <div>
      <h3 class="font-bold text-base text-blue-800 mb-2">About Wish Weaver</h3>
      <p>Wish Weaver is a local, browser-based card creator. Combine your photos with customizable messages, fonts, and stickers ‚Äî then export high-resolution PNGs ready to share. No accounts, no uploads: your images stay on your device.</p>
    </div>

    <div>
      <h3 class="font-bold text-base text-blue-800 mb-2">Privacy & Help</h3>
      <p>
        <a href="/WEAVER/privacy.html" class="text-blue-700 underline">Privacy Policy</a><br />
        <a href="/WEAVER/help.html" class="text-blue-700 underline">How to use</a>
      </p>
    </div>

    <div>
      <h3 class="font-bold text-base text-blue-800 mb-2">Contact & Links</h3>
      <p>
        Have questions? <a href="/WEAVER/contact.html" class="text-blue-700 underline">Contact us</a>.<br />
        <a href="/WEAVER/about.html" class="text-blue-700 underline">About</a>
      </p>
    </div>
  </div>

  <div class="max-w-6xl mx-auto mt-6 text-center text-xs text-gray-500">
    designed by <a id="weaverLink" href="https://weaver.example.com" target="_blank" rel="noopener" class="text-blue-700 underline">weaver</a> ‚Äî &copy; 2025 Wish Weaver
  </div>
</footer>
<!-- END: Footer -->

  <script>
  /************************************************************************
   * Wish Weaver ‚Äî single-file app
   * Fix: Prevent taint by converting external saved image URLs into data: URLs
   * Also keeps earlier fixes: emoji stickers, watermark, share, etc.
   ************************************************************************/

  // DOM references
  const canvas = document.getElementById('cardCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const previewContainer = document.getElementById('previewContainer');
  const imageUpload = document.getElementById('imageUpload');
  const imagePlaceholder = document.getElementById('imagePlaceholder');
  const generateButton = document.getElementById('generateButton');
  const outputArea = document.getElementById('outputArea');
  const finalImagePreview = document.getElementById('finalImagePreview');
  const downloadLink = document.getElementById('downloadLink');
  const shareButton = document.getElementById('shareButton');
  const aspectRatio = document.getElementById('aspectRatio');
  const exportDpr = document.getElementById('exportDpr');
  const fileWarn = document.getElementById('fileWarn');
  const outputWatermark = document.getElementById('outputWatermark');

  const wishOverlay = document.getElementById('wishOverlay');
  const subOverlay = document.getElementById('subOverlay');
  const stickerPalette = document.getElementById('stickerPalette');
  const stickerLayerContainer = document.getElementById('stickerLayerContainer');

  const inputs = {
    wishText: document.getElementById('wishText'),
    wishColor: document.getElementById('wishColor'),
    wishSize: document.getElementById('wishSize'),
    wishFont: document.getElementById('wishFont'),
    wishRotate: document.getElementById('wishRotate'),
    wishStrokeEnable: document.getElementById('wishStrokeEnable'),
    wishStrokeColor: document.getElementById('wishStrokeColor'),
    wishStrokeWidth: document.getElementById('wishStrokeWidth'),

    subText: document.getElementById('subText'),
    subColor: document.getElementById('subColor'),
    subSize: document.getElementById('subSize'),
    subFont: document.getElementById('subFont'),
    subRotate: document.getElementById('subRotate'),
    subStrokeEnable: document.getElementById('subStrokeEnable'),
    subStrokeColor: document.getElementById('subStrokeColor'),
    subStrokeWidth: document.getElementById('subStrokeWidth'),
  };

  const undoButton = document.getElementById('undoButton');
  const resetButton = document.getElementById('resetButton');
  const saveButton = document.getElementById('saveDesign');
  const loadButton = document.getElementById('loadDesign');
  const clearSavedBtn = document.getElementById('clearSaved');
  const helpBtn = document.getElementById('helpButton');

  // state
  let dpr = parseFloat(window.devicePixelRatio || 1);
  let uploadedImage = new Image();
  let isImageLoaded = false;
  let activeOverlay = null;    // dom node being dragged
  let activeSticker = null;    // selected sticker layer
  let offset = { x: 0, y: 0 }; // pointer offset to center
  let historyStack = [];
  const MAX_HISTORY = 30;
  const STORAGE_KEY = 'wishweaver_saved_design_v3';
  let stickerCounter = 0;
  let lastExportDataUrl = null; // store last exported image data URL

  // helpers
  function percentOrDefault(val, def=50) {
    const n = parseFloat(val);
    return Number.isFinite(n) ? n : def;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function debounce(fn, ms=100){ let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a), ms);} }

  function swapFontClass(el, newFont) {
    const fonts = ['font-oswald','font-caveat','font-inter','font-mono'];
    fonts.forEach(f=>el.classList.remove(f));
    el.classList.add(newFont);
  }

  // Convert external image URL -> data: URL safely (returns dataURL string)
  async function loadImageFromSource(src) {
    // If it's already a data URL, return immediately
    if (!src) throw new Error('No image source provided');
    if (src.startsWith('data:')) return src;

    // Try to fetch the resource and convert to data URL
    try {
      const resp = await fetch(src, { mode: 'cors' }); // try CORS fetch
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const blob = await resp.blob();
      return await blobToDataURL(blob);
    } catch (err) {
      // fetch failed (likely CORS) ‚Äî we can't safely draw the external image without CORS.
      console.error('loadImageFromSource failed for', src, err);
      throw new Error('Unable to fetch external image (CORS blocked). Please re-upload the image file using the Upload control.');
    }
  }

  function blobToDataURL(blob) {
    return new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.onerror = (e) => rej(e);
      fr.readAsDataURL(blob);
    });
  }

  // update overlays (including stroke style)
  function updateTextOverlays() {
    // wish
    wishOverlay.textContent = inputs.wishText.value;
    wishOverlay.style.color = inputs.wishColor.value;
    wishOverlay.style.fontSize = inputs.wishSize.value + 'px';
    swapFontClass(wishOverlay, inputs.wishFont.value);
    wishOverlay.style.transform = `translate(-50%, -50%) rotate(${inputs.wishRotate.value}deg)`;
    applyStrokeStyleToOverlay(wishOverlay, inputs.wishStrokeEnable.checked, inputs.wishStrokeColor.value, parseFloat(inputs.wishStrokeWidth.value), parseFloat(inputs.wishSize.value));

    // sub
    const words = inputs.subText.value.trim().split(/\s+/).filter(Boolean);
    if (words.length > 20) inputs.subText.value = words.slice(0,20).join(' ');
    subOverlay.textContent = inputs.subText.value;
    subOverlay.style.color = inputs.subColor.value;
    subOverlay.style.fontSize = inputs.subSize.value + 'px';
    swapFontClass(subOverlay, inputs.subFont.value);
    subOverlay.style.transform = `translate(-50%, -50%) rotate(${inputs.subRotate.value}deg)`;
    applyStrokeStyleToOverlay(subOverlay, inputs.subStrokeEnable.checked, inputs.subStrokeColor.value, parseFloat(inputs.subStrokeWidth.value), parseFloat(inputs.subSize.value));
  }

  // Apply stroke to DOM overlay (live preview) - scaled down to avoid heavy/thick look
  function applyStrokeStyleToOverlay(el, enable, color, width, fontSizePx) {
    const base = Math.max(0, Number(width) || 0);
    const strokePx = Math.max(0, Math.round(base * ( (fontSizePx || 48) / 48 ) * 0.6));
    if (enable && strokePx > 0) {
      el.style.webkitTextStroke = `${strokePx}px ${color}`;
      el.style.textStroke = `${strokePx}px ${color}`;
      const w = Math.max(1, strokePx);
      const shadows = [
        `-${w}px -${w}px 0 ${color}`,
        `${w}px -${w}px 0 ${color}`,
        `-${w}px ${w}px 0 ${color}`,
        `${w}px ${w}px 0 ${color}`
      ].join(', ');
      el.style.textShadow = shadows;
    } else {
      el.style.webkitTextStroke = '';
      el.style.textStroke = '';
      el.style.textShadow = '2px 2px 4px rgba(0,0,0,0.45)';
    }
  }

  // canvas resizing (no cumulative transform)
  function resizeCanvas() {
    const cssW = previewContainer.clientWidth;
    const [w,h] = aspectRatio.value.split(':').map(Number);
    const cssH = Math.round(cssW * (h / w));
    previewContainer.style.height = cssH + 'px';
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    dpr = parseFloat(window.devicePixelRatio || 1);
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0,0,cssW,cssH);
    if (isImageLoaded) drawImageOnCanvas();
  }

  function drawImageOnCanvas() {
    if (!isImageLoaded) {
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      return;
    }
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const iw = uploadedImage.width, ih = uploadedImage.height;
    const scale = Math.max(cssW / iw, cssH / ih);
    const tW = iw * scale, tH = ih * scale;
    const x = (cssW - tW) / 2, y = (cssH - tH) / 2;
    ctx.clearRect(0,0,cssW,cssH);
    ctx.drawImage(uploadedImage, x, y, tW, tH);
  }

  // save/undo helpers
  function saveHistory(el) {
    if (!el) return;
    const snapshot = {
      id: el.id || el.dataset.layerId || null,
      type: el.classList.contains('sticker-layer') ? 'sticker' : 'text',
      top: el.style.top || '50%',
      left: el.style.left || '50%',
      transform: el.style.transform || ''
    };
    historyStack.push(snapshot);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
    undoButton.disabled = false;
  }
  function undoLastMove() {
    if (!historyStack.length) return;
    const last = historyStack.pop();
    let el = null;
    if (last.type === 'sticker') el = document.querySelector(`.sticker-layer[data-layer-id="${last.id}"]`);
    else el = document.getElementById(last.id);
    if (el) {
      el.style.top = last.top;
      el.style.left = last.left;
      el.style.transform = last.transform;
    }
    if (!historyStack.length) undoButton.disabled = true;
  }

  // reset
  function resetAll() {
    wishOverlay.style.top = '25%'; wishOverlay.style.left = '50%'; wishOverlay.style.transform = 'translate(-50%,-50%) rotate(0deg)';
    subOverlay.style.top = '80%'; subOverlay.style.left = '50%'; subOverlay.style.transform = 'translate(-50%,-50%) rotate(0deg)';
    stickerLayerContainer.innerHTML = '';
    activeSticker = null;

    aspectRatio.value = '1:1';
    inputs.wishText.value = 'Happy Moments!';
    inputs.wishColor.value = '#ffffff';
    inputs.wishSize.value = 48;
    inputs.wishFont.value = 'font-oswald';
    inputs.wishRotate.value = 0;
    inputs.wishStrokeEnable.checked = false;
    inputs.wishStrokeColor.value = '#000000';
    inputs.wishStrokeWidth.value = 2;

    inputs.subText.value = 'Wishing you a wonderful day filled with joy and laughter!';
    inputs.subColor.value = '#facc15';
    inputs.subSize.value = 20;
    inputs.subFont.value = 'font-inter';
    inputs.subRotate.value = 0;
    inputs.subStrokeEnable.checked = false;
    inputs.subStrokeColor.value = '#000000';
    inputs.subStrokeWidth.value = 1;

    updateTextOverlays();
    historyStack = [];
    undoButton.disabled = true;

    uploadedImage = new Image();
    isImageLoaded = false;
    imageUpload.value = '';
    imagePlaceholder.style.display = 'flex';
    generateButton.disabled = true;
    generateButton.style.pointerEvents = 'none';

    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    outputArea.classList.add('hidden');
    finalImagePreview.style.display = 'none';
    downloadLink.href = '';
    lastExportDataUrl = null;

    // hide watermark until next export
    if (outputWatermark) outputWatermark.style.display = 'none';

    resizeCanvas();
  }

  // sticker creation (emoji-based)
  function addSticker(emoji, left='50%', top='50%', scale=1, rotate=0, fontSize=48) {
    const id = 'sticker_' + (++stickerCounter);
    const el = document.createElement('div');
    el.className = 'sticker-layer';
    el.dataset.layerId = id;
    el.style.left = left;
    el.style.top = top;
    // store scale/rotate/fontsize via dataset so export can read them
    el.dataset.scale = scale;
    el.dataset.rotate = rotate;
    el.dataset.fontsize = fontSize;
    el.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${rotate}deg)`;
    el.setAttribute('tabindex', '0');

    const span = document.createElement('div');
    span.className = 'emoji';
    span.textContent = emoji;
    span.style.fontSize = fontSize + 'px';
    el.appendChild(span);

    stickerLayerContainer.appendChild(el);
    selectSticker(el);
    return el;
  }

  function selectSticker(el) {
    if (activeSticker) activeSticker.classList.remove('selected');
    activeSticker = el;
    if (!el) { return; }
    el.classList.add('selected');
  }

  // sticker palette click -> add emoji sticker
  document.querySelectorAll('#stickerPalette .sticker-thumb').forEach(btn => {
    btn.addEventListener('click', () => {
      const emoji = btn.dataset.emoji || 'üéâ';
      const existing = stickerLayerContainer.children.length;
      const left = 50 + (existing % 5) * 6;
      const top = 50 + Math.floor(existing / 5) * 6;
      const st = addSticker(emoji, left + '%', top + '%', 1, 0, 48);
      selectSticker(st);
    });
  });

  // pointer handlers for dragging text and stickers
  function getPointerCoords(e) { return { x: e.clientX ?? 0, y: e.clientY ?? 0 }; }

  function pointerDownHandler(e) {
    if (e.button !== undefined && e.button !== 0) return; // only primary
    let target = e.target;
    if (target.closest && target.closest('.sticker-layer')) target = target.closest('.sticker-layer');
    if (!target) return;
    if (target.classList.contains('draggable-text') || target.classList.contains('sticker-layer')) {
      e.preventDefault();
      activeOverlay = target;
      saveHistory(activeOverlay);
      if (activeOverlay.classList.contains('sticker-layer')) selectSticker(activeOverlay);
      else { if (activeSticker) { activeSticker.classList.remove('selected'); activeSticker = null; } }
      const parentRect = previewContainer.getBoundingClientRect();
      const leftPercent = percentOrDefault(activeOverlay.style.left, 50);
      const topPercent = percentOrDefault(activeOverlay.style.top, 50);
      const centerX = parentRect.left + parentRect.width * leftPercent / 100;
      const centerY = parentRect.top + parentRect.height * topPercent / 100;
      const { x, y } = getPointerCoords(e);
      offset.x = x - centerX;
      offset.y = y - centerY;
      try { activeOverlay.setPointerCapture?.(e.pointerId); } catch(err) {}
      activeOverlay.style.zIndex = 99;
    } else {
      // clicked outside overlays -> deselect sticker
      if (activeSticker) { activeSticker.classList.remove('selected'); activeSticker = null; }
    }
  }

  function pointerMoveHandler(e) {
    if (!activeOverlay) return;
    e.preventDefault();
    const parentRect = previewContainer.getBoundingClientRect();
    const { x, y } = getPointerCoords(e);
    const newCenterX = x - offset.x;
    const newCenterY = y - offset.y;
    let leftPct = ((newCenterX - parentRect.left) / parentRect.width) * 100;
    let topPct = ((newCenterY - parentRect.top) / parentRect.height) * 100;
    leftPct = clamp(leftPct, 0, 100);
    topPct = clamp(topPct, 0, 100);
    activeOverlay.style.left = leftPct.toFixed(2) + '%';
    activeOverlay.style.top = topPct.toFixed(2) + '%';
  }

  function pointerUpHandler(e) {
    if (!activeOverlay) return;
    try { activeOverlay.releasePointerCapture?.(e.pointerId); } catch(err) {}
    activeOverlay.style.zIndex = '';
    activeOverlay = null;
  }

  // keyboard nudging for overlays
  function overlayKeyHandler(e) {
    const el = e.currentTarget;
    const step = e.shiftKey ? 10 : 1;
    let left = percentOrDefault(el.style.left, 50);
    let top = percentOrDefault(el.style.top, 50);
    let moved = false;
    if (e.key === 'ArrowLeft') { left -= (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowRight') { left += (step / (previewContainer.clientWidth/100)); moved=true; }
    if (e.key === 'ArrowUp') { top -= (step / (previewContainer.clientHeight/100)); moved=true; }
    if (e.key === 'ArrowDown') { top += (step / (previewContainer.clientHeight/100)); moved=true; }
    if (moved) {
      e.preventDefault();
      saveHistory(el);
      el.style.left = clamp(left,0,100).toFixed(2) + '%';
      el.style.top = clamp(top,0,100).toFixed(2) + '%';
      undoButton.disabled = false;
    }
  }

  wishOverlay.addEventListener('keydown', overlayKeyHandler);
  subOverlay.addEventListener('keydown', overlayKeyHandler);

  // wire global pointer events
  document.addEventListener('pointerdown', pointerDownHandler);
  document.addEventListener('pointermove', pointerMoveHandler, { passive:false });
  document.addEventListener('pointerup', pointerUpHandler);

  // Delete key for sticker removal
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && activeSticker) {
      activeSticker.remove();
      activeSticker = null;
    }
  });

  // image upload
  imageUpload.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    if (file.size > 8 * 1024 * 1024) {
      fileWarn.textContent = 'Large image detected (>8MB). Upload may be slow; consider a smaller image.';
      fileWarn.classList.remove('hidden');
    } else fileWarn.classList.add('hidden');

    const reader = new FileReader();
    reader.onload = function(evt) {
      uploadedImage = new Image();
      // uploaded image is local data URL so no taint here
      uploadedImage.onload = function() {
        isImageLoaded = true;
        imagePlaceholder.style.display = 'none';
        // ensure generate button is enabled & clickable
        generateButton.disabled = false;
        generateButton.style.pointerEvents = 'auto';
        resizeCanvas();
        drawImageOnCanvas();
        // also update overlays to match any input changes
        updateTextOverlays();
      };
      uploadedImage.onerror = function() { console.error('Image load error'); };
      uploadedImage.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  });

  // export / generate final PNG (renders image, emoji-stickers, text into an offscreen canvas using chosen export DPI)
  function generateFinalImage() {
    try {
      if (!isImageLoaded) {
        alert('Please upload an image first.');
        return;
      }

      // Ensure overlays reflect latest settings before export
      updateTextOverlays();
      // draw base on visible canvas one last time so sizes are correct
      drawImageOnCanvas();

      const exportScale = parseFloat(exportDpr.value) || 2;
      const cssW = canvas.width / dpr;
      const cssH = canvas.height / dpr;
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = Math.round(cssW * exportScale);
      exportCanvas.height = Math.round(cssH * exportScale);
      const ectx = exportCanvas.getContext('2d', { alpha: false });
      ectx.setTransform(exportScale, 0, 0, exportScale, 0, 0);

      // draw background image center-crop
      const iw = uploadedImage.width, ih = uploadedImage.height;
      const scale = Math.max(cssW / iw, cssH / ih);
      const tW = iw * scale, tH = ih * scale;
      const x = (cssW - tW) / 2, y = (cssH - tH) / 2;
      ectx.clearRect(0,0,cssW,cssH);
      ectx.drawImage(uploadedImage, x, y, tW, tH);

      // draw stickers by z-index ascending (emoji-based)
      const stickerEls = Array.from(stickerLayerContainer.children);
      stickerEls.sort((a,b) => (parseInt(a.style.zIndex||3) - parseInt(b.style.zIndex||3)));
      stickerEls.forEach(el => {
        drawStickerOnExportCtx(ectx, el);
      });

      // draw texts
      drawTextOnExportCtx(ectx, wishOverlay, {
        text: inputs.wishText.value,
        color: inputs.wishColor.value,
        fontSize: parseFloat(inputs.wishSize.value),
        fontClass: inputs.wishFont.value,
        rotateDeg: parseFloat(inputs.wishRotate.value),
        strokeEnable: inputs.wishStrokeEnable.checked,
        strokeColor: inputs.wishStrokeColor.value,
        strokeWidth: parseFloat(inputs.wishStrokeWidth.value)
      });
      drawTextOnExportCtx(ectx, subOverlay, {
        text: inputs.subText.value,
        color: inputs.subColor.value,
        fontSize: parseFloat(inputs.subSize.value),
        fontClass: inputs.subFont.value,
        rotateDeg: parseFloat(inputs.subRotate.value),
        strokeEnable: inputs.subStrokeEnable.checked,
        strokeColor: inputs.subStrokeColor.value,
        strokeWidth: parseFloat(inputs.subStrokeWidth.value)
      });

      // subtle watermark: "designed by weaver" at bottom center (drawn into image)
      try {
        const watermarkText = 'designed by weaver';
        const fontSize = Math.max(12, Math.round(cssW * 0.03)); // relative, but small
        ectx.save();
        ectx.globalAlpha = 0.55;
        ectx.font = `${fontSize}px Inter`;
        ectx.textAlign = 'center';
        ectx.textBaseline = 'bottom';
        // subtle stroke for readability
        ectx.lineWidth = Math.max(1, Math.round(fontSize * 0.08));
        ectx.strokeStyle = 'rgba(0,0,0,0.35)';
        ectx.strokeText(watermarkText, cssW / 2, cssH - Math.round(fontSize * 0.25));
        ectx.fillStyle = 'rgba(255,255,255,0.95)';
        ectx.fillText(watermarkText, cssW / 2, cssH - Math.round(fontSize * 0.25));
        ectx.restore();
      } catch (err) {
        console.warn('Watermark draw failed', err);
      }

      const dataUrl = exportCanvas.toDataURL('image/png');
      lastExportDataUrl = dataUrl;

      // Show result in UI
      finalImagePreview.src = dataUrl;
      finalImagePreview.style.display = 'block';
      downloadLink.href = dataUrl;
      downloadLink.download = 'wishweaver-card.png';
      outputArea.classList.remove('hidden');

      // show clickable watermark overlay above generated image
      if (outputWatermark) {
        outputWatermark.style.display = 'inline-block';
        outputWatermark.setAttribute('href', 'https://weaver.example.com');
        outputWatermark.setAttribute('target', '_blank');
        outputWatermark.setAttribute('rel', 'noopener');
      }

      // scroll to output
      finalImagePreview.scrollIntoView({ behavior: 'smooth' });
    } catch (err) {
      console.error('generateFinalImage error', err);
      alert('Failed to generate image. Open the console for details.');
    }
  }
function drawTextOnExportCtx(ectx, el, options) {
  const cssW = canvas.width / dpr;
  const cssH = canvas.height / dpr;
  const left = percentOrDefault(el.style.left,50);
  const top = percentOrDefault(el.style.top,50);
  const x = (left/100) * cssW;
  const y = (top/100) * cssH;

  // Prefer the overlay's actual rendered text (preserves any manual newlines),
  // fallback to options.text if needed.
  const rawText = String((el && el.textContent) ? el.textContent : (options.text || ''));

  const fontSize = options.fontSize || parseFloat(window.getComputedStyle(el).fontSize) || 24;
  let family = 'Inter';
  if ((options.fontClass||'').includes('oswald')) family='Oswald';
  else if ((options.fontClass||'').includes('caveat')) family='Caveat';
  else if ((options.fontClass||'').includes('mono')) family='Roboto Mono';

  // Use the overlay's clientWidth to match preview wrapping. Convert to export coords
  // (el.clientWidth is in CSS px for the preview area which maps 1:1 to cssW units).
  let wrapWidth = (el && el.clientWidth) ? el.clientWidth : Math.max(40, cssW - Math.max(16, cssW * 0.04));
  // ensure wrapWidth not bigger than canvas
  wrapWidth = Math.min(wrapWidth, cssW - 8);

  // helper: wrap a single paragraph into lines using the ectx measurement
  function wrapParagraph(ctx, text, maxWidth) {
    const words = text.split(/\s+/).filter(Boolean);
    const lines = [];
    if (words.length === 0) return [''];
    let current = words[0];
    for (let i = 1; i < words.length; i++) {
      const w = words[i];
      const test = current + ' ' + w;
      if (ctx.measureText(test).width <= maxWidth) current = test;
      else { lines.push(current); current = w; }
    }
    if (current) lines.push(current);
    return lines;
  }

  ectx.save();
  ectx.translate(x,y);
  ectx.rotate((options.rotateDeg||0) * Math.PI/180);
  ectx.font = `${fontSize}px ${family}`;
  ectx.textAlign = 'center';
  ectx.textBaseline = 'middle';

  // split into paragraphs by explicit newlines, then wrap each paragraph to overlay width
  const paragraphs = rawText.split(/\r?\n/);
  const lines = [];
  for (let p of paragraphs) {
    p = p.replace(/^\s+|\s+$/g, ''); // trim
    if (p === '') { lines.push(''); continue; }
    const wrapped = wrapParagraph(ectx, p, wrapWidth);
    wrapped.forEach(l => lines.push(l));
  }

  // compute line height and vertical start so block is centered at overlay position
  const lineHeight = Math.max(fontSize * 1.12, 1.12 * fontSize);
  const totalHeight = lines.length * lineHeight;
  let startY = - (totalHeight / 2) + (lineHeight / 2);

  // scale stroke for export to avoid overly thick stroke
  const baseStroke = Math.max(0, Number(options.strokeWidth) || 0);
  const strokeExportPx = Math.max(0, baseStroke * 0.6);

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineY = startY + (i * lineHeight);
    if (options.strokeEnable && strokeExportPx > 0) {
      ectx.lineWidth = Math.max(1, strokeExportPx);
      ectx.strokeStyle = options.strokeColor || '#000';
      ectx.strokeText(line, 0, lineY);
    }
    ectx.fillStyle = options.color || '#fff';
    ectx.fillText(line, 0, lineY);
  }

  ectx.restore();
}

  function drawStickerOnExportCtx(ectx, el) {
    // we now support emoji-based stickers (text). Draw the emoji on canvas.
    const cssW = canvas.width / dpr;
    const cssH = canvas.height / dpr;
    const left = percentOrDefault(el.style.left,50);
    const top = percentOrDefault(el.style.top,50);
    const x = (left/100) * cssW;
    const y = (top/100) * cssH;

    // read transform params
    const tr = el.style.transform || '';
    const m = tr.match(/scale\((-?[0-9.]+)\)\s*rotate\((-?[0-9.]+)deg\)/);
    const scale = m ? parseFloat(m[1]) : (parseFloat(el.dataset.scale) || 1);
    const rotate = m ? parseFloat(m[2]) : (parseFloat(el.dataset.rotate) || 0);
    const fontSize = parseFloat(el.dataset.fontsize) || parseFloat((el.querySelector('.emoji')||{}).style.fontSize) || 48;

    const emojiEl = el.querySelector('.emoji');
    if (!emojiEl) return;
    const emoji = emojiEl.textContent || '';

    ectx.save();
    ectx.translate(x, y);
    ectx.rotate(rotate * Math.PI/180);
    ectx.scale(scale, scale);
    // pick a font that supports emoji ‚Äî system fallback will handle it
    ectx.font = `${fontSize}px serif`;
    ectx.textAlign = 'center';
    ectx.textBaseline = 'middle';
    // draw emoji - fill (no stroke needed)
    ectx.fillText(emoji, 0, 0);
    ectx.restore();
  }

  // events wiring
  aspectRatio.addEventListener('change', () => { resizeCanvas(); });
  window.addEventListener('resize', debounce(()=> { resizeCanvas(); }, 120));
  Object.values(inputs).forEach(inp => { inp.addEventListener('input', () => { updateTextOverlays(); if (isImageLoaded) drawImageOnCanvas(); }); });

  stickerLayerContainer.addEventListener('pointerdown', (ev) => {
    const st = ev.target.closest && ev.target.closest('.sticker-layer');
    if (st) selectSticker(st);
  });

  // Save / Load designs
  saveButton.addEventListener('click', () => {
    const stickerNodes = Array.from(stickerLayerContainer.children).map(el => {
      const span = el.querySelector('.emoji');
      const left = el.style.left || '50%';
      const top = el.style.top || '50%';
      const tr = el.style.transform || '';
      const scale = parseFloat(el.dataset.scale) || 1;
      const rotate = parseFloat(el.dataset.rotate) || 0;
      const fontsize = parseFloat(el.dataset.fontsize) || (span ? parseFloat(span.style.fontSize || 48) : 48);
      const z = el.style.zIndex || 3;
      return { emoji: span ? span.textContent : 'üéâ', left, top, scale, rotate, fontsize, z };
    });
    const state = {
      imageDataUrl: uploadedImage && uploadedImage.src ? uploadedImage.src : null, // store data: or external URL if any
      aspectRatio: aspectRatio.value,
      wish: {
        text: inputs.wishText.value,
        color: inputs.wishColor.value,
        size: inputs.wishSize.value,
        font: inputs.wishFont.value,
        rotate: inputs.wishRotate.value,
        strokeEnable: inputs.wishStrokeEnable.checked,
        strokeColor: inputs.wishStrokeColor.value,
        strokeWidth: inputs.wishStrokeWidth.value,
        top: wishOverlay.style.top || '25%',
        left: wishOverlay.style.left || '50%',
        transform: wishOverlay.style.transform || ''
      },
      sub: {
        text: inputs.subText.value,
        color: inputs.subColor.value,
        size: inputs.subSize.value,
        font: inputs.subFont.value,
        rotate: inputs.subRotate.value,
        strokeEnable: inputs.subStrokeEnable.checked,
        strokeColor: inputs.subStrokeColor.value,
        strokeWidth: inputs.subStrokeWidth.value,
        top: subOverlay.style.top || '80%',
        left: subOverlay.style.left || '50%',
        transform: subOverlay.style.transform || ''
      },
      stickers: stickerNodes
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    alert('Design saved locally in your browser.');
  });

  // load button uses loadImageFromSource to avoid taint
  loadButton.addEventListener('click', async () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) { alert('No saved design found.'); return; }
    try {
      const st = JSON.parse(raw);
      if (st.imageDataUrl) {
        try {
          const safeDataUrl = await loadImageFromSource(st.imageDataUrl);
          uploadedImage = new Image();
          uploadedImage.onload = () => { 
            isImageLoaded = true; 
            imagePlaceholder.style.display='none'; 
            generateButton.disabled = false; 
            generateButton.style.pointerEvents = 'auto'; 
            resizeCanvas(); 
            drawImageOnCanvas(); 
            updateTextOverlays(); 
          };
          uploadedImage.onerror = function(e){ console.error('Loaded image error', e); alert('Failed to load the saved image ‚Äî please re-upload the image manually.'); };
          uploadedImage.src = safeDataUrl;
        } catch (err) {
          // couldn't convert external URL -> dataURL (CORS) ‚Äî inform user and abort loading image
          alert(err.message + '\nOpen the saved design and re-upload the image file using the Upload control.');
        }
      }
      if (st.aspectRatio) aspectRatio.value = st.aspectRatio;
      if (st.wish) {
        inputs.wishText.value = st.wish.text || inputs.wishText.value;
        inputs.wishColor.value = st.wish.color || inputs.wishColor.value;
        inputs.wishSize.value = st.wish.size || inputs.wishSize.value;
        inputs.wishFont.value = st.wish.font || inputs.wishFont.value;
        inputs.wishRotate.value = st.wish.rotate || inputs.wishRotate.value;
        inputs.wishStrokeEnable.checked = st.wish.strokeEnable || false;
        inputs.wishStrokeColor.value = st.wish.strokeColor || inputs.wishStrokeColor.value;
        inputs.wishStrokeWidth.value = st.wish.strokeWidth || inputs.wishStrokeWidth.value;
        wishOverlay.style.top = st.wish.top || wishOverlay.style.top;
        wishOverlay.style.left = st.wish.left || wishOverlay.style.left;
        wishOverlay.style.transform = st.wish.transform || wishOverlay.style.transform;
      }
      if (st.sub) {
        inputs.subText.value = st.sub.text || inputs.subText.value;
        inputs.subColor.value = st.sub.color || inputs.subColor.value;
        inputs.subSize.value = st.sub.size || inputs.subSize.value;
        inputs.subFont.value = st.sub.font || inputs.subFont.value;
        inputs.subRotate.value = st.sub.rotate || inputs.subRotate.value;
        inputs.subStrokeEnable.checked = st.sub.strokeEnable || false;
        inputs.subStrokeColor.value = st.sub.strokeColor || inputs.subStrokeColor.value;
        inputs.subStrokeWidth.value = st.sub.strokeWidth || inputs.subStrokeWidth.value;
        subOverlay.style.top = st.sub.top || subOverlay.style.top;
        subOverlay.style.left = st.sub.left || subOverlay.style.left;
        subOverlay.style.transform = st.sub.transform || subOverlay.style.transform;
      }
      // stickers
      stickerLayerContainer.innerHTML = '';
      if (st.stickers && Array.isArray(st.stickers)) {
        st.stickers.forEach(s => {
          const el = addSticker(s.emoji || 'üéâ', s.left, s.top, s.scale, s.rotate, s.fontsize || 48);
          el.style.zIndex = s.z || 3;
        });
      }
      updateTextOverlays();
      resizeCanvas();
      alert('Design loaded.');
    } catch (err) {
      console.error(err);
      alert('Failed to load saved design.');
    }
  });

  clearSavedBtn.addEventListener('click', () => {
    localStorage.removeItem(STORAGE_KEY);
    alert('Saved design cleared.');
  });

  helpBtn.addEventListener('click', () => {
    const msg = `Use Wish Weaver:\n\n1. Upload an image.\n2. Choose aspect ratio and DPI.\n3. Edit main and sub text, pick fonts, rotate, and add optional stroke.\n4. Add stickers from the picker (click to add). Select stickers to move or press Delete to remove.\n5. Drag text and stickers to position. Use arrow keys to nudge (Shift for larger steps).\n6. Click "GENERATE SHARABLE CARD" to export and get a downloadable PNG. All processing happens locally in your browser.`;
    alert(msg);
  });

  // enable generate when image loaded
  function updateButtonsState() {
    undoButton.disabled = historyStack.length === 0;
    generateButton.disabled = !isImageLoaded;
    if (isImageLoaded) generateButton.style.pointerEvents = 'auto';
    else generateButton.style.pointerEvents = 'none';
  }
  setInterval(updateButtonsState, 400);

  // generate button click wiring - robust handler
  function handleGenerateClick(e) {
    e?.preventDefault?.();
    if (generateButton.disabled || !isImageLoaded) {
      generateButton.classList.add('opacity-70');
      setTimeout(()=> generateButton.classList.remove('opacity-70'), 160);
      if (!isImageLoaded) alert('Please upload an image first.');
      return;
    }
    const prevText = generateButton.textContent;
    generateButton.disabled = true;
    generateButton.textContent = 'Generating‚Ä¶';
    setTimeout(() => {
      try {
        updateTextOverlays();
        generateFinalImage();
      } catch (err) {
        console.error('handleGenerateClick error', err);
        alert('Failed to generate image. See console for details.');
      } finally {
        generateButton.textContent = prevText || 'GENERATE SHARABLE CARD';
        generateButton.disabled = !isImageLoaded;
      }
    }, 80);
  }

  // Sharing: utils to convert dataURL -> Blob
  async function dataURLtoBlob(dataurl) {
    const res = await fetch(dataurl);
    const blob = await res.blob();
    return blob;
  }

  // Share button handler (single share button)
  shareButton.addEventListener('click', async () => {
    if (!lastExportDataUrl) { alert('Please generate the card first.'); return; }
    try {
      const blob = await dataURLtoBlob(lastExportDataUrl);
      const file = new File([blob], 'wishweaver-card.png', { type: 'image/png' });

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: 'My Wish Weaver Card', text: 'Check out this card I made.' });
        return;
      }

      if (navigator.share) {
        try {
          await navigator.share({ title: 'Wish Weaver', text: 'Check out this card I made.', url: lastExportDataUrl });
          return;
        } catch (err) {
          // fallback below
        }
      }

      // Final fallback: open the image data URL in a new tab so user can save / share manually
      const w = window.open();
      w.document.write(`<title>Share image</title><img src="${lastExportDataUrl}" style="max-width:100%;">`);
      w.document.close();
    } catch (err) {
      console.error('Share failed', err);
      alert('Sharing is not supported in this browser. Please download the image and share it from your phone.');
    }
  });

  // reset & undo hooks
  resetButton.addEventListener('click', resetAll);
  undoButton.addEventListener('click', undoLastMove);

  // initial setup
  updateTextOverlays();
  resizeCanvas();
  generateButton.disabled = true;
  generateButton.style.pointerEvents = 'none';

  // Done.
  </script>
</body>
</html>
